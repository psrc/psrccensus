---
title: "Using microdata 3:  \nScript multiyear PUMS functions"
description: >
  Suggestions for applying PUMS functions longitudinally
output: html_vignette
vignette: >
  %\VignetteIndexEntry{"Using microdata 3:  \nScript multiyear PUMS functions"}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
library(psrccensus)
library(magrittr)
library(dplyr)
library(srvyr)
library(knitr)
```

## Time: the next dimension

Now that you've learned to calculate single-survey results from the PUMS microdata, what's to stop you from calculating trends across multiple surveys? As it turns out, there are a few potholes in that road to avoid.

### Hint #1 - Be mindful of span

This item relates to confidence levels: the Census Bureau strongly advises against drawing comparisons from surveys with overlapping spans (e.g. 2015-19 & 2016-20 5yr data), since identical observations are present in both surveys, which means you may underestimate change or overestimate certainty. 5-year data are best if 5-year intervals answer the need; to get annual trends, you'll need to use the 1yr data (which involves more uncertainty). Remember to use Z-scores to determine whether trend values can be considered statistically distinct.

### Hint #2 - Compare data dictionaries 

Although they may seem consistent at first blush, many PUMS variable codes, values, and labels have changed during the course of the program. If you plan to compare data across multiple surveys, you'll either want to confirm the variables of interest have remained consistent, or write your code to handle the differences among them. In some cases, the way data were reported--or the way the question was asked--might preclude accurate multi-year comparisons at your desired level of detail.

### <a id="inter-year-inflation"></a>Hint #3 - Adjust dollar values for inter-year inflation

Due to inflation, the value of a dollar declines over time; to achieve a true multi-year comparison of price or income variables, these must be adjusted to be in terms of a common reference year (typically, the most recent year for which data is available). This is done by multiplying by a ratio of the relevant annual values of a price index (the ratio is known as a 'deflator'). We recommend the Personal Consumption Expenditures (PCE) Index, as it is updated to remain valid across years, while the more famous Consumer Price Index (CPI) is left unchanged after its initial release. The [example](#example) illustrates how aggregate median household income and its MOE can be adjusted to a common dollar year.

### Hint #4 - Minimize downloads

While writing multi-year functions, keep in mind `get_psrc_pums()` downloads and combines all possible variables before returning those you requested, so it's efficient to group operations on the same survey (year/span) rather than to call `get_psrc_pums()` separately for each desired measure. We recommend combining your data retrieval, manipulation and summarization operations for a single year into a function, which you can then apply across multiple surveys. This approach requires only as many downloads as you have surveys--resulting in faster operations and lower demand on memory.


### Example

  ```{r apply function across PUMS years, message=FALSE, eval=FALSE}
library(psrccensus)
library(magrittr)
library(dplyr)
library(srvyr)
library(data.table)

# Adjust for inflation
# --requires FRED key in .Renviron, see fredr documentation
deflate_multiyr <- function(data, dyear, refyear){
  x <- fredr(series_id = "DPCERG3A086NBEA",                                                        
             observation_start = as_date(paste0(dyear,"-01-01")),
             observation_end = as_date(paste0(refyear,"-01-01")))
  factor <- last(x$value) / first(x$value)
  rs <- setDT(data) %>% .[, grep("sum|median|mean", colnames(.)):=lapply(.SD, function(x) round(x * factor)),
                   .SDcols=grep("sum|median|mean", colnames(.))] %>% setDF()
  return(rs)
}

# Build a single year function first
# -- it can include as many individual stat analyses as needed (see list items at end)
pums_singleyear <- function(dyear, refyear, span=1){
  hh_df <- get_psrc_pums(span, dyear, "h", c("HINCP","AGEP","HRACE","LNGI","SCHL"))
  hh_df %<>% mutate(
    ed_attain = factor(case_when(grepl("(Bach|Mast|Prof|Doct)", SCHL)  ~ "Bachelor's degree or higher",
                                 !is.na(SCHL)                          ~ "Less than a Bachelor's degree")),
    lmtd_engl = factor(case_when(grepl("^No one", LNGI) ~ "Limited English proficiency",
                                 !is.na(LNGI)           ~ "English proficient")))
  dvars <- c("HRACE","lmtd_engl","ed_attain") %>% as.list()
  singleyr_rs <- list()
  singleyr_rs[[1]] <- pums_bulk_stat(hh_df, "count", group_var_list=dvars, incl_na=FALSE)
  singleyr_rs[[2]] <- pums_bulk_stat(hh_df, "median", "HINCP", dvars, incl_na=FALSE) %>% 
    deflate_multiyr(dyear, refyear)
  # singleyr_rs[[3]] <- ...
  return(singleyr_rs)
}

# Multiyear function runs the single-year function across years and combines results
pums_multiyear <- function(dyears){
  refyear <- max(dyears)
  multiyear_rs <- mapply(pums_singleyear, dyears, refyear) %>% lapply(as.vector) %>% 
    do.call(rbind, .) %>% as.data.frame() %>% setDT() %>% lapply(rbindlist)
  return(multiyear_rs)
}

x <- pums_multiyear(2015:2019)

```
